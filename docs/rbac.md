
> **摘要**
> 本文记录了自动化实验室系统权限设计的演进过程。从最初的纯 RBAC 模型，到前后端解耦的尝试，最终演化为“后端感知组件”的混合模型，解决了“API 原子权限与 UI 业务功能不匹配”以及“权限重叠导致无法精准移除”的核心架构矛盾。
---
## 1. 核心矛盾：后端原子性 vs 前端业务性
在构建复杂的自动化实验室系统时，我们面临一个经典的架构矛盾：
*   **后端视角**：权限是原子的，对应 API 的 `Perm(Resource, Action, Scope)`。
*   **用户视角**：权限是业务的，对应 UI 界面上的“功能组件”或“按钮”。
这种视角的错位导致了权限管理的根本性难题。
## 2. 第一阶段：纯粹的 API 粒度 RBAC
起初，我们采用了最硬核的后端权限模型。
### 设计模式
每一个 Handler 绑定一个权限三元组：
$$Perm(Resource, Action, Scope)$$
拦截器负责拦截请求，校验用户是否拥有该三元组权限。
### 遭遇困境
**“前端如何展示权限列表？”**
如果我们直接把系统里 200 多个 API 丢给管理员（User Endpoint, Experiment Endpoint, Reprot Endpoint...），让他们去勾选：
- [ ] `GET /api/v1/reports`
- [ ] `POST /api/v1/experiments`
管理员无法理解这些 URL 与业务功能的对应关系。他们眼中的是：
- [ ] **“实验报告组件”**
- [ ] **“设备控制面板”**
**结论**：纯粹的 API RBAC 虽然逻辑完美，但**完全不可用**于非技术人员的业务配置。
---
## 3. 第二阶段：前后端解耦的“美好幻想”
为了解决 UI 展示问题，我们试图将 **组件（Component）** 与 **API 权限（Perms）** 的映射逻辑下放到前端。
### 设计逻辑
*   **映射维护**：前端维护一个 `f(Component) -> Set(Perms)` 的映射表。
*   **操作流程**：
    1.  管理员在 UI 上修改组件勾选状态（例如勾选“组件 A”）。
    2.  **核心逻辑**：前端遍历**当前所有被选中**的组件，计算它们权限的**并集**：
        $$Perms_{Final} = \bigcup_{c \in Selected} f(c)$$
        *(注意：不是简单的对原权限集合进行增量 `+` 或 `-`，而是基于当前组件状态的**全量重算**)*。
    3.  前端将计算出的 `Perms_Final` 全量发送给后端（PUT 覆盖），后端仅存储 API 权限列表。
    
    > **为什么必须全量重算？**
    > 因为权限和组件是 `多对多` 关系。
    > 如果只做简单减法（例如 `Current_Perms - Perms(A)`），会错误地移除掉那些**“虽然 A 用到了，但 B 也正在用”**的公共权限（如 `P1`），导致组件 B 功能受损。全量并集计算是唯一正确的数学逻辑。
### 优势
*   **开发解耦**：前端增加 API 调用只需修改前端映射，后端无需感知 UI 变化。
### 致命漏洞：权限重叠（Permission Overlap）
假设我们有三个组件，它们复用了相同的 API 权限：
*   **组件 A** (用户管理): 需要 `{P1, P2}`
*   **组件 B** (项目成员): 需要 `{P1, P3}`
*   **组件 C** (财务审核): 需要 `{P2, P4}`
**场景复现**：
1.  **初始状态**：管理员为用户配置了 **组件 A**、**组件 B** 和 **组件 C**。
    *   后端存储权限池：`{P1, P2, P3, P4}` (并集)。
2.  **修改操作**：管理员**取消勾选**了 **组件 A**。
    *   前端计算剩余组件（B + C），需要的权限为 `{P1, P3}` + `{P2, P4}` = `{P1, P2, P3, P4}`。
    *   **惊人的发现**：权限集合完全没有变化！
    *   前端请求更新权限，依然提交了 `{P1, P2, P3, P4}`。
3.  **Bug 爆发**：用户刷新页面。
    *   前端拿到用户权限 `{P1, P2, P3, P4}`。
    *   前端尝试重建 UI：
        *   检查组件 A？需要 `{P1, P2}` -> 用户全有 -> **自动勾选 A**。
    *   **结果**：管理员明明删除了组件 A，但因为组件 B 提供了 `P1`，组件 C 提供了 `P2`，导致组件 A 的“生存条件”依然被满足，它像幽灵一样**复活了**。
**结论**：仅仅依靠 API 权限集合反推业务功能，**无法精准还原**用户的“配置意图”。信息在 `多对一` 的混合过程中丢失了。
---
## 4. 第三阶段：引入“组件”作为一等公民 (Component-First)
为了彻底解决“僵尸权限”问题，后端必须感知“组件”这一概念，但我们拒绝回到强耦合的老路上。
### 新架构：组件代码 (Component Code)
我们在后端引入极其轻量的资源：**Component** (仅包含 `id` 和 `code`，无其它业务属性)。
#### 1. 显式关联：语义化契约
现在的 Role 结构发生了变化：
*   **Role 绑定**：不再只绑定 Permissions，同时绑定一组 `Component_Codes`。
*   **保存逻辑**：BFF/前端告知后端：“这个角色拥有 A、B 两个组件，以及它们计算出的权限清单。”
*   **回传逻辑**：后端直接返回 `authorized_components: ["comp_user_list", "comp_settings"]`。
**前端渲染**：
前端直接拿 `authorized_components` 列表去控制 UI 显隐。哪怕 A 和 B 的 API 权限完全重叠，如果 B 存在，而 A 不出现在`authorized_components` 中，A也不允许被显示。
#### 2. 安全哲学：准入控制 vs 交互规范
**疑问**：如果前端映射表写错，或者用户篡改参数，导致“组件 A”看到了“全量数据”怎么办？
**回答**：
API 权限控制的本质是**准入（Access Control）**。
> 想象一位 **高级经理**，他拥有查看所有薪资数据的 API 权限 (`scope: all`)。
> 如果他正在使用一个简单的“新员工入职”工具（组件），并未预期看到敏感数据。但如果该组件配置错误，请求了 CEO 的薪资。
> **后端判定**：该用户是高级经理，有权查看薪资 -> **放行**。
> **结果**：经理在入职工具里看到了 CEO 薪资。
> **本质**：经理 **本就可以** 看到所有薪资（Scope 未扩大），但在“入职”这个业务场景下看到 CEO 薪资是不合适的。
这属于 **交互规范问题（UI bug）**，而非 **后端安全漏洞**。
*   后端职责是**守门**：确保“实习生”绝对无法获取 CEO 薪资，无论 UI 如何请求。
*   前端职责是**导游**：引导有权限的人在正确的界面看正确的数据。
这种设计极大简化了后端逻辑，将复杂的业务意图还原权交还给前端。

## 5. 变更同步：零代码干预 (Zero-Code Sync)
在此架构下，权限变更的维护成本被转移到了“配置页”的自动计算上，极大降低了沟通成本。
### 场景一：前端组件升级 (Frontend Evolution)
*场景：组件新增“导出”按钮，需要 `POST /export` 权限。*
1.  **前端跟进**：前端开发者在 `f(Component)` 中增加新权限声明。
2.  **部署上线**：管理员进入配置页，系统自动检测到新的权限需求。
3.  **同步生效**：点击 **“保存”** -> 权限自动同步。
### 场景二：后端安全加固 (Backend Hardening)
*场景：后端将原本公开的 API `GET /api/stats` 升级为需权限 `stats:view`。*
1.  **后端部署**：API 开始拦截未授权请求（此时旧请求会报 403）。
2.  **前端跟进**：前端开发者同步更新 `f(Component)` 声明。
3.  **同步生效**：管理员点击 **“保存”** -> 权限自动同步。
**核心价值**：
无论变更源头在前端（加功能）还是后端（加锁），**同步流程完全一致**。系统永远维持“组件 -> 权限”的单一事实来源，彻底消灭了“后端不仅要写代码，还要写 SQL 刷权限数据”的痛苦。
---
## 6. 边界情况与局限性 (Edge Cases & Limitations)
虽此架构解决了 UI 与 API 的映射难题，但它依然有其适用边界，需配合其他机制使用。
### 6.1 动态数据权限 (Dynamic Data Scopes)
此框架擅长处理 **“功能权限”** (Functionality)，但难以直接处理复杂的 **“数据权限”**。
*   **问题**：组件 `ReportList` 对普通用户需要 `report:view:own`，对经理需要 `report:view:all`。
*   **局限**：如果前端映射表中写死 `f(ReportList) -> {report:view:all}`，则普通用户会被赋予过高权限。
*   **解法**：
    *   **RBAC + ABAC 混合**：前端仅请求通用权限 `report:view`。
    *   **后端决策**：API 收到 `report:view` 请求时，根据 `User.Department` 或 `User.Role` 动态叠加 Scope 过滤条件（如 `WHERE owner_id = current_user`）。
    *   *结论：本框架解决“能不能打开页面”，后端逻辑解决“能看到某行数据”。*
### 6.2 后端隐式依赖 (Backend Implicit Dependencies)
*   **问题**：前端点击“开始实验”按钮，调用 `POST /experiment/start`。后端逻辑中会**自动触发**一个 `Notification Service` 发送邮件。
*   **局限**：如果发送邮件需要独立的 `mail:send` 权限，而前端映射表 `f(StartButton)` 漏写了它（因为前端并未直接调用 mail 接口），会导致业务中断。
---
## 总结
| 阶段 | 核心机制 | 优点 | 缺点 |
| :--- | :--- | :--- | :--- |
| **Phase 1** | API 原子权限 | 简单、安全 | 业务含义缺失，配置困难 |
| **Phase 2** | 前端映射 + API 存储 | 前后端解耦 | **权限重叠引发状态不一致** |
| **Phase 3** | **组件清单 + API 权限** | **状态精准，体验闭环** | 引入轻量组件概念 |
最终方案证明：在复杂的 B 端系统中，为了用户体验，后端适度感知前端概念（组件）是必要的权衡。
